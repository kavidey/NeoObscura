
// Verilog netlist produced by program backanno, Version Radiant Software (64-bit) 2023.1.1.200.1

// backanno -o address_decoder_impl_1_vo.vo -sp High-Performance_1.2V -w -neg -gui address_decoder_impl_1.udb 
// Netlist created on Wed Nov 29 23:42:18 2023
// Netlist written on Wed Nov 29 23:42:25 2023
// Design is for device iCE40UP5K
// Design is for package SG48
// Design is for performance grade High-Performance_1.2V

`timescale 1 ns / 1 ps

module decoder ( sel, addr );
  input  [1:0] addr;
  output [3:0] sel;
  wire   addr_c_0, addr_c_1, \inverted_sel[0] , \inverted_sel[1] , 
         \inverted_sel[2] , \inverted_sel[3] ;

  SLICE_0 SLICE_0( .D1(addr_c_0), .B1(addr_c_1), .C0(addr_c_0), .A0(addr_c_1), 
    .F0(\inverted_sel[0] ), .F1(\inverted_sel[1] ));
  SLICE_2 SLICE_2( .C1(addr_c_0), .B1(addr_c_1), .B0(addr_c_0), .A0(addr_c_1), 
    .F0(\inverted_sel[2] ), .F1(\inverted_sel[3] ));
  sel_3_ \sel[3]_I ( .PADDO(\inverted_sel[3] ), .sel3(sel[3]));
  sel_2_ \sel[2]_I ( .PADDO(\inverted_sel[2] ), .sel2(sel[2]));
  sel_1_ \sel[1]_I ( .PADDO(\inverted_sel[1] ), .sel1(sel[1]));
  sel_0_ \sel[0]_I ( .PADDO(\inverted_sel[0] ), .sel0(sel[0]));
  addr_1_ \addr[1]_I ( .PADDI(addr_c_1), .addr1(addr[1]));
  addr_0_ \addr[0]_I ( .PADDI(addr_c_0), .addr0(addr[0]));
endmodule

module SLICE_0 ( input D1, B1, C0, A0, output F0, F1 );
  wire   GNDI;

  lut4 addr_c_0_I_0_4( .A(GNDI), .B(B1), .C(GNDI), .D(D1), .Z(F1));
  gnd DRIVEGND( .PWR0(GNDI));
  lut40001 addr_c_0_I_0( .A(A0), .B(GNDI), .C(C0), .D(GNDI), .Z(F0));

  specify
    (D1 => F1) = (0:0:0,0:0:0);
    (B1 => F1) = (0:0:0,0:0:0);
    (C0 => F0) = (0:0:0,0:0:0);
    (A0 => F0) = (0:0:0,0:0:0);
  endspecify

endmodule

module lut4 ( input A, B, C, D, output Z );

  LUT4 #("0xCCFF") INST10( .A(A), .B(B), .C(C), .D(D), .Z(Z));
endmodule

module gnd ( output PWR0 );

  VLO INST1( .Z(PWR0));
endmodule

module lut40001 ( input A, B, C, D, output Z );

  LUT4 #("0xFAFA") INST10( .A(A), .B(B), .C(C), .D(D), .Z(Z));
endmodule

module SLICE_2 ( input C1, B1, B0, A0, output F0, F1 );
  wire   GNDI;

  lut40002 addr_c_0_I_0_2( .A(GNDI), .B(B1), .C(C1), .D(GNDI), .Z(F1));
  gnd DRIVEGND( .PWR0(GNDI));
  lut40003 addr_c_0_I_0_3( .A(A0), .B(B0), .C(GNDI), .D(GNDI), .Z(F0));

  specify
    (C1 => F1) = (0:0:0,0:0:0);
    (B1 => F1) = (0:0:0,0:0:0);
    (B0 => F0) = (0:0:0,0:0:0);
    (A0 => F0) = (0:0:0,0:0:0);
  endspecify

endmodule

module lut40002 ( input A, B, C, D, output Z );

  LUT4 #("0x3F3F") INST10( .A(A), .B(B), .C(C), .D(D), .Z(Z));
endmodule

module lut40003 ( input A, B, C, D, output Z );

  LUT4 #("0xDDDD") INST10( .A(A), .B(B), .C(C), .D(D), .Z(Z));
endmodule

module sel_3_ ( input PADDO, output sel3 );
  wire   VCCI;

  BB_B_B \sel_pad[3].bb_inst ( .T_N(VCCI), .I(PADDO), .O(), .B(sel3));
  vcc DRIVEVCC( .PWR1(VCCI));

  specify
    (PADDO => sel3) = (0:0:0,0:0:0);
  endspecify

endmodule

module BB_B_B ( input T_N, I, output O, inout B );

  BB_B INST10( .T_N(T_N), .I(I), .O(O), .B(B));
endmodule

module vcc ( output PWR1 );

  VHI INST1( .Z(PWR1));
endmodule

module sel_2_ ( input PADDO, output sel2 );
  wire   VCCI;

  BB_B_B \sel_pad[2].bb_inst ( .T_N(VCCI), .I(PADDO), .O(), .B(sel2));
  vcc DRIVEVCC( .PWR1(VCCI));

  specify
    (PADDO => sel2) = (0:0:0,0:0:0);
  endspecify

endmodule

module sel_1_ ( input PADDO, output sel1 );
  wire   VCCI;

  BB_B_B \sel_pad[1].bb_inst ( .T_N(VCCI), .I(PADDO), .O(), .B(sel1));
  vcc DRIVEVCC( .PWR1(VCCI));

  specify
    (PADDO => sel1) = (0:0:0,0:0:0);
  endspecify

endmodule

module sel_0_ ( input PADDO, output sel0 );
  wire   VCCI;

  BB_B_B \sel_pad[0].bb_inst ( .T_N(VCCI), .I(PADDO), .O(), .B(sel0));
  vcc DRIVEVCC( .PWR1(VCCI));

  specify
    (PADDO => sel0) = (0:0:0,0:0:0);
  endspecify

endmodule

module addr_1_ ( output PADDI, input addr1 );
  wire   GNDI;

  BB_B_B \addr_pad[1].bb_inst ( .T_N(GNDI), .I(GNDI), .O(PADDI), .B(addr1));
  gnd DRIVEGND( .PWR0(GNDI));

  specify
    (addr1 => PADDI) = (0:0:0,0:0:0);
  endspecify

endmodule

module addr_0_ ( output PADDI, input addr0 );
  wire   GNDI;

  BB_B_B \addr_pad[0].bb_inst ( .T_N(GNDI), .I(GNDI), .O(PADDI), .B(addr0));
  gnd DRIVEGND( .PWR0(GNDI));

  specify
    (addr0 => PADDI) = (0:0:0,0:0:0);
  endspecify

endmodule
